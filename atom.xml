<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>满天星爱我</title>
  
  <subtitle>心若浮沉，淺笑安然</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T16:00:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>满天星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM之垃圾回收机制</title>
    <link href="http://yoursite.com/2019/03/28/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/28/JVM/JVM之垃圾回收机制/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2019-03-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断对象是否还“存活”"><a href="#判断对象是否还“存活”" class="headerlink" title="判断对象是否还“存活”"></a>判断对象是否还“存活”</h1><blockquote><p>垃圾收集器在对堆进行回收前，需要先确定这些对象中哪些还“存活”着，哪些已经“死去”(也就是不被任何引用类型所引用)。</p></blockquote><p>基于这个目前有两种算法可判断对象是否存活</p><ul><li><strong>引用计数算法</strong></li><li><strong>可达性分析算法</strong></li></ul><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>优点：</p><ul><li>实现简单</li><li>判断效率高</li></ul><p>缺点：</p><ul><li>很难解决对象之间相互循环引用的问题</li></ul><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<strong>GC Roots</strong>没有任何引用链相连时，则证明此对象是不可用的。</p><p>可作为<strong>GC Roots</strong>的对象包括下面几种</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><strong>强引用</strong></p><p>  在程序中普遍存在，类似<code>Object obj = new Object()</code>这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象</p></li><li><p><strong>软引用</strong></p><p>  用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了<strong>SoftReference</strong>类来实现软引用。</p></li><li><p>弱引用</p><p>  用来描述非必须对象，但它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了<strong>WeakReference</strong>类来实现弱引用。</p></li><li><p><strong>虚引用</strong></p><p>  它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了<strong>PhantomReference</strong>类来实现虚引用。</p></li></ul><h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ul><li>如果对象在进行可达性分析后发现没有与<strong>GC Roots</strong>相连接的引用链，拿它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚引用调用过，虚引用将这两种情况都视为“没有必要执行”。</li><li>如果此对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会放置在一个叫做<strong>F-Queue</strong>的队列中，并在稍后由一个虚拟机自动建立的，但并不承若会等待它运行结束</li><li>这样做的原因是，如果一个对象在<code>finalize()</code>方法中执行缓慢，或者发生了死循环，将会很有可能会导致<strong>F-Queue</strong>队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，例如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这个时候还没有逃脱，拿基本上它就真的被回收了</li></ul><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>最基础的收集算法，算法分为“标记”和“清除”两个阶段</li><li>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>效率问题，标记和清除过程的效率都不高</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul><p>   <img src="https://upload-images.jianshu.io/upload_images/2349677-e15554b5e1fc821a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt></p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>每次对其中的一块进行内存回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可</li><li>实现简单，运行高效</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>将内存缩小为原来的一半，付出的代价太高</li></ul><p>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代的对象98%是朝生夕死的，所以并不需要按照1 : 1的比例来划分内存空间，而是将内存分为一块较大的Eden和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。Hotspot虚拟机默认Eden和Survivor的大小比例是8 : 1。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>专门针对老年代提出的一种“标记-整理”算法</li><li>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2349677-544a7dee2c1775e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ul><li>根据对象存活周期的不同将内存划分为几块</li><li><p>将Java堆分为新生代和老年代，根据各个年代的特点采用最适合的收集算法</p><p>  新生代：每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>；</p><p>  老年代：对象存活率高、没有额外空间对它进行分配担保，就必须使用“<strong>标记-清理</strong>”或“<strong>标记-整理</strong>”算法来回收</p></li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如下图展示了7中不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。</p><p><img src="https://upload-images.jianshu.io/upload_images/2349677-5cb8496c84cb4132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><ul><li>最基本、历史最悠久的收集器，在<strong>JDK1.3</strong>之前是虚拟机<strong>新生代</strong>收集的唯一选择</li><li><p>它是单线程收集器，使用一个CPU或一条线程去完成垃圾收集工作，并且在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p>  <img src="https://upload-images.jianshu.io/upload_images/2349677-575f8ecb47909a4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾shou’ji自然可以获得最高的单线程收集效率</p></li><li><p>在进行垃圾收集时，必须暂停其他所有的工作线程</p></li><li><p>它用于桌面应用，分配给虚拟机管理的内存一般不会太大。收集几十兆甚至一两百兆的新生代，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不频繁发生，这点停顿是可以接受的。Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择</p></li></ul><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><ul><li>它是Serial收集器的多线程版本</li><li><p>除了使用多线程进行垃圾收集以外，其余行为包括Serial收集器可用的所有控制参数(例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实际上这两种收集器也共用了相当多的代码</p><p><img src="https://upload-images.jianshu.io/upload_images/2349677-b5b081e1b99584a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>它默认开启的收集线程数与CPU的数量相同，在CPU非常多(譬如32个)的环境下，可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数</p></li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>在多CPU的环境下，它对于GC时系统资源的利用很有好处</li><li><p>除了Serial收集器外，目前只有它能与CMS收集器(这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器)配合工作</p></li><li><p>在单CPU环境下不会有比Serial收集器更好的效果，甚至由于多线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证超越Serial收集器</p></li><li><p>它是许多运行在Server模式下的虚拟机中首选的新生代收集器</p></li></ul><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><ul><li>新生代收集器</li><li>使用复制算法</li><li>并行的多线程收集器</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li><p>该收集器目标则是达到一个可控制的吞吐量(<strong>所谓吞吐量就是CPU用户运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</strong>)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></li><li><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</p></li><li><p>提供两个参数来控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数</p></li><li><p>打开<code>-XX:+UseAdaptiveSizePolicy</code>参数，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为<strong>GC自适应的调节策略</strong></p></li></ul><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><ul><li>它是Serial收集器的老年代版本</li><li>单线程收集器</li><li>使用“<strong>标记-整理</strong>”算法</li></ul><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>它也是被<strong>Client</strong>模式下的虚拟机使用</li><li><p>如果在<strong>Server</strong>模式下，它还有两大用途：一个是在JDK1.5及之前的版本中与Paralle Scavenge收集器搭配使用；另一个就是作为CMS收集器的后备方案，在并发收集发生<strong>Concurrent Mode Failure</strong>的时候使用</p><p><img src="https://upload-images.jianshu.io/upload_images/2349677-18a3b9b0f21a8d5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><ul><li>它是Parallel Scavenge收集器的老年代版本</li><li>多线程收集器</li><li>使用“<strong>标记整理</strong>”</li></ul><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li>在注重吞吐量及CPU资源敏感的场合，可以优先考虑<strong>Parallel Scavenge</strong>加<strong>Parallel Old</strong>收集器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2349677-4e6b688b4c6b573c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><ul><li>是一种以获取最短回收停顿时间为目标的收集器</li><li>多线程收集器</li><li>使用“<strong>标记-清除</strong>”算法</li></ul><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><p>它的运作过程相对复杂，整个过程分为4个步骤，包括：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行<strong>GC Roots Tracing</strong>的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</p><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMG收集器的内存回收过程是与用户一起并发地执行的，如下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间</p><p><img src="https://upload-images.jianshu.io/upload_images/2349677-86e7516af2e9058e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt="image.png"></p><p>它的主要优点</p><ul><li>并发收集、低停顿</li><li>在Sun的一些官方文档被称为并发低停顿收集器</li></ul><p>它有三个显著的缺点</p><ul><li>CMS收集器对CPU资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程(或者说CPU资源)而导致应用程序变慢，总吞吐量会降低</li><li>CMS收集器无法处理<strong>浮动垃圾</strong>，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。要是CMS运行期间预留的内存无法满足程序需要，j就会出现一次“Concurrent Mode Failure”失败，这个时候虚拟机将启动后备方案：临时启用Serial Old收集器来重新进行老年代的垃圾收集</li><li>CMS是一款基于“<strong>标记-清除</strong>”算法实现的收集器，收集时会产生大量空间碎片。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是垃圾收集器理论进一步发展的产物，它与前面的CMS收集器相比有两个显著的改进：</p><ul><li>基于“<strong>标记-整理</strong>”算法实现的收集器，也就是说它不会产生空间碎片</li><li>它可以非常精确地控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，着几乎是实时Java的垃圾收集器的特征了</li></ul><p>G1将整个Java堆(包括新生代、老年代)划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。区域划分及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。</p><h1 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h1><h2 id="对象分配规则"><a href="#对象分配规则" class="headerlink" title="对象分配规则"></a>对象分配规则</h2><h3 id="对象优先在Eden区分配。"><a href="#对象优先在Eden区分配。" class="headerlink" title="对象优先在Eden区分配。"></a>对象优先在Eden区分配。</h3><p> 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次<strong>Minor GC</strong></p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul><li>这里的大对象指得是需要连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</li><li>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝(新生代采用复制算法收集内存)</li></ul><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p> 虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将年龄设为1。对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshod</code>来设置</p><h5 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h5><p> 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</p><h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p> 当发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否小于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC;如果不允许，则也要改为进行一次Full GC。</p><blockquote><p><strong>注意</strong></p><ul><li>新生代GC(Minor GC): 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性。所以Minor GC 非常频繁，一般回收速度也比较快。</li><li>老年代GC(MajorGC/Full GC):<br>指发生在老年代的GC，出现了Major GC，经常会伴随着至少一次的Minor GC（但非绝对的，在ParalleScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。MajorGC的速度一般会比Minor GC慢10倍以上</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;判断对象是否还“存活”&quot;&gt;&lt;a href=&quot;#判断对象是否还“存活”&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否还“存活”&quot;&gt;&lt;/a&gt;判断对象是否还“存活”&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;垃圾收集器在对堆进行回收前，需要先确定这些
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="垃圾回收" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM之内存溢出</title>
    <link href="http://yoursite.com/2019/03/18/JVM/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2019/03/18/JVM/JVM之内存溢出/</id>
    <published>2019-03-17T16:00:00.000Z</published>
    <updated>2019-03-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存溢出和内存泄漏的区别"><a href="#内存溢出和内存泄漏的区别" class="headerlink" title="内存溢出和内存泄漏的区别"></a>内存溢出和内存泄漏的区别</h1><ul><li><p><strong>内存溢出</strong><br>在Java虚拟机向系统申请内存时，由于虚拟机内部的各存储区域存储空间都有限制(可以通过指定虚拟机的某些参数来优化调整内存大小)，例如当堆内存被占满后，虚拟机再向系统申请内存是申请不到的，此时就会发生内存溢出</p></li><li><p><strong>内存泄漏</strong><br>内存泄漏是针对<strong>GC</strong>(垃圾回收器)来说的，<strong>GC</strong>在进行对象回收时，一些无用对象仍然持续占有内存，无法得到及时释放，最后造成内存空间的浪费</p></li></ul><h1 id="关于内存溢出有以下几种分类"><a href="#关于内存溢出有以下几种分类" class="headerlink" title="关于内存溢出有以下几种分类"></a>关于内存溢出有以下几种分类</h1><ul><li><strong>Java堆溢出</strong></li><li><strong>虚拟机栈和本地方法栈溢出</strong></li><li><strong>方法区和运行时常量池溢出</strong></li></ul><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>Java堆用于存储对象实例，只要不断的创建对象，并且保证<strong>GC Roots</strong>到对象之间有可达路径来避免垃圾回收机制清除这些对象，当对象数量达到堆的最大容量后就会产生内存溢出异常。</p><p>下面举个例子来验证一下堆内存溢出，为了方便实验，先把堆大小限制为10M，不可扩展(将堆的最小值<code>-Xms</code>参数与最大值<code>-Xmx</code>参数设置为一样即可避免堆自动扩展)，然后通过指定虚拟机的参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>可以让虚拟机在出现内存溢出时<code>Dump</code>出当前的内存堆转储快照以便事后进行分析</p><pre><code>public class HeapTest {public static void main(String[] args){    List&lt;Object&gt; list = new ArrayList&lt;&gt;();    while (true) {        list.add(new Object());    }    }}</code></pre><p>结果如下：</p><pre><code>java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid13288.hprof ...Heap dump file created [13500082 bytes in 0.076 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat java.util.Arrays.copyOf(Arrays.java:3210)at java.util.Arrays.copyOf(Arrays.java:3181)at java.util.ArrayList.grow(ArrayList.java:265)at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)at java.util.ArrayList.add(ArrayList.java:462)at com.company.HeapTest.main(HeapTest.java:10)</code></pre><p>当然Java堆溢出不仅仅是以上情况，还有可能是内存泄漏导致的，比如内存泄漏地比较多了，浪费了大量的空间内存，这样就会导致堆内存会快速的被占满，然后造成内存溢出，到底是内存溢出还是内存泄漏还需要通过工具去查证，这里就不详细说了，网上有很多教程。</p><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>虚拟机栈也就是我们平常所说的栈，它在Java虚拟机规范中有两种异常:</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<strong>StackOverflowError</strong>异常</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出<strong>OverOfMemoryError</strong>异常 </li></ul><p>上面所说的栈深度其实就是栈中栈帧的数量，操作系统分给JVM的内存是有限的，而JVM分给虚拟机栈的内存也是有限的，如果方法调用过多，创建的栈帧的数量也就越多，那么最终就会导致虚拟机栈溢出；当然我们可以通过<code>-Xss</code>参数来指定虚拟机栈的最大深度。另外，如果将虚拟机栈设置为可动态扩展，那么同样的当栈深度不够时，JVM会自动申请扩展，如果此时申请不到足够的内存空间就会抛出<strong>OverOfMemoryError</strong>异常</p><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>在JDK1.6以前，很多人愿意把方法区称为“永久代”，本质上两者并不等价，其实方法区只是Java虚拟机规范的一种定义，或者说用永久代来实现方法区而已，也就是说永久代仅仅是HotSpot的概念，对于其它虚拟机来说是不存在永久代的概念的。而使用永久代来实现方法区，更容易遇到内存溢出问题，所以在JDK1.7的HotSpot中，原本放在永久代中的字符串常量池被移到了堆中。</p><p>接下来我们使用<code>String.intern()</code>方法来验证JDK1.6版本中方法区或者说是常量池溢出的情况，不过在此之前先来了解一下此方法在JDK1.6和JDK1.7中的作用：</p><p><strong>jdk1.6中</strong></p><ul><li>如果字符串常量池中已经包含了一个等于(equals)此String对象的字符串，则返回常量池中这个字符串的String对象</li><li>否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。</li></ul><p><strong>jdk1.7中</strong></p><ul><li>如果字符串常量池中已经包含了一个等于(equals)此String对象的字符串，则返回常量池中这个字符串的String对象</li><li>否则，将复制一份此String对象的引用到字符串常量池中，并返回此引用</li></ul><p>他们的区别其实就是：<br>如果字符串常量池中不包含一个等于(equals)此String对象的字符串，那么</p><ul><li>在jdk1.6中，就会将堆中的字符串对象复制一份到字符串常量池中，然后返回该字符串对象</li><li>而在jdk1.7中，会将堆中的字符串对象的引用复制一份到字符串常量池中，然后返回该引用</li></ul><p>为了方便测试jdk1.6中方法区的溢出，我们先通过<code>-XX:PermSize</code>和 <code>-XX:MaxPermSize</code>参数来限制方法区的大小，然后下面是测试代码</p><pre><code>public static void main(String[] args){    List&lt;String&gt; list = new ArrayList&lt;String&gt;();    int i = 0;    while (true) {        list.add(String.valueOf(i++).intern());    }    }</code></pre><p>运行结果如下：</p><pre><code>java.lang.OutOfMemoryError: PermGen spaceDumping heap to java_pid7588.hprof ...Heap dump file created [109527439 bytes in 0.777 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen spaceat java.lang.String.intern(Native Method)at com.company.HeapTest.main(HeapTest.jav   a:11)Process finished with exit code 1</code></pre><p>我们应该很清楚的发现第一行报错信息：<br><code>java.lang.OutOfMemoryError: PermGen space</code><br>而<code>PermGen space</code>就是永久代，显而易见方法区溢出了，也说明了在jdk1.6中字符串常量池位于方法区内，而使用JDK1.7运行这段程序就不会得到相同的结果。</p><p>最后我们再来验证一下JDK1.7中字符串常量池是否被移到了堆中，首先设置一下VM参数<code>-Xms10m -Xmx10m</code>，将堆内存限制到10M，然后再运行上面的代码，会出现如下结果</p><pre><code>java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid10284.hprof ...Heap dump file created [21832557 bytes in 0.279 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat java.lang.Integer.toString(Integer.java:403)at java.lang.String.valueOf(String.java:3099)at com.company.HeapTest.main(HeapTest.java:14)</code></pre><p>结果如出一辙，抛出了堆内存溢出的异常信息，说明JDK1.7中确实是把字符串常量池放到了堆中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存溢出和内存泄漏的区别&quot;&gt;&lt;a href=&quot;#内存溢出和内存泄漏的区别&quot; class=&quot;headerlink&quot; title=&quot;内存溢出和内存泄漏的区别&quot;&gt;&lt;/a&gt;内存溢出和内存泄漏的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;内存溢出&lt;/strong&gt;
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="内存溢出" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM之内存管理机制</title>
    <link href="http://yoursite.com/2019/03/15/JVM/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/15/JVM/JVM之内存管理机制/</id>
    <published>2019-03-14T16:00:00.000Z</published>
    <updated>2019-03-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时内存区域划分"><a href="#运行时内存区域划分" class="headerlink" title="运行时内存区域划分"></a>运行时内存区域划分</h1><blockquote><p>Java源文件(<code>.java文件</code>)会被Java编译器编译为字节码文件(<code>.class文件</code>)，再由JVM中的类加载器去加载各个类的字节码文件，加载完成后交给JVM执行引擎执行。</p></blockquote><p>在Java程序执行过程中，会动态地将内存划分为如下几大区域：</p><ul><li>虚拟机栈</li><li>堆</li><li>方法区</li><li>程序计数器</li><li>本地方法栈</li></ul><p>其中这些区域又可划分为两大类</p><ul><li><p>由所有线程共享的区域</p><p>  方法区、堆、本地方法栈</p></li><li><p>线程私有的数据区</p><p>  虚拟机栈、程序计数器</p></li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul><li>是一块较小的内存</li><li>作用：当前线程所执行的字节码的行号指示器</li><li>通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>为了线程切换后能恢复到正确的执行位置，因此每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储</li><li>它的区域为“线程私有”的内存</li><li>此内存区域是唯一一个在Java虚拟机规范中没有规定任何<strong>OutOfMemoryError</strong>情况的区域</li></ul><p>在Java的内存分配中有这么一段话：</p><blockquote><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<strong>Native</strong>方法，这个计数器值为空。</p></blockquote><p>上述这句话引入了一个问题：</p><p>我们知道，程序计数器用来存放字节码指令的地址；通过这个地址，虚拟机就能知道执行到哪里，下一步执行什么，但是调用<code>native</code>方法，值就变空了，那么机器不就直接崩溃了吗？</p><p>解释：当线程中调用native方法的时候，则重新启动一个新的线程，那么新的线程的计数器为空则不会影响当前线程的计数器，相互独立。而调用此方法的线程就会处于阻塞状态，直到另外一个线程执行结束才会恢复到运行状态</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul><li>线程私有，声明周期与线程相同</li><li>方法在执行时会创建一个<strong>栈帧</strong>，每一个方法被调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程</li></ul><blockquote><p>上面提到了栈帧，那么什么是栈帧呢<br>解释：栈帧用来存储<strong>局部变量表</strong>、<strong>操作栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。</p></blockquote><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li>存放编译期可知的各种<strong>基本类型数据</strong>(<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)、<strong>对象引用</strong>(reference类型)和<strong>returnAddress类型</strong>(指向了一条字节码指令的地址)</li><li>除了64位的<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间，其余的数据类型只占用1个</li><li>当进入一个方法，这个方法需要在栈帧中分配多大局部变量空间时完全确定的，方法在运行期间不会改变局部变量表的大小</li></ul><h3 id="栈异常"><a href="#栈异常" class="headerlink" title="栈异常"></a>栈异常</h3><ul><li>线程请求的的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常</li><li>若虚拟机可动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，但扩展无法申请到足够内存时会抛出<code>StackOverflowError</code>异常</li><li></li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul><li>与虚拟机栈的作用类似</li><li>区别：虚拟机栈为虚拟机执行Java方法服务，而本地方法则为虚拟机使用到的Native方法服务</li><li>Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一</li><li>本地方法栈也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常</li></ul><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><ul><li>是Java虚拟机所管理的内存中最大的一块</li><li>被所有线程共享</li><li>所有的对象实例以及数组都要在堆上分配</li><li>现在的收集器基本都采用分代收集算法，所以Java堆还可以细分为：<strong>新生代</strong>和<strong>老生代</strong></li><li>如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<strong>OutOfMemoryError</strong>异常</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>所有线程共享的内存区域</li><li>存储已被虚拟机加载的类信息、常量、静态变量</li><li>垃圾收集在这个区域比较少出现</li><li>这个区域的内存回收目标主要对常良池的回收和对类型的卸载</li><li>当方法去无法满足内存分配需求时，将抛出<strong>OutOfMemoryError</strong>异常</li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ul><li>方法区的一部分</li><li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器存放的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li><li>除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中</li></ul><h1 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h1><p><strong>主流访问方式有两种：</strong>句柄和直接指针</p><ul><li><p><strong>句柄</strong><br><br>使用句柄询问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中包含了对象的实例数据和类型数据各自的具体地址信息，如下图所示：</p><p>  <img src="https://upload-images.jianshu.io/upload_images/2349677-238abede0d7116e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p><strong>优势：reference中存储的是稳定的句柄地址，在对象被移动时(垃圾收集时移动对象是非常普遍的行为)只会改变句柄中的实例数据指针，而reference本身不需要被修改</strong></p></blockquote></li><li><p><strong>直接指针</strong><br><br>使用直接指针方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如图所示：<br>  <img src="https://upload-images.jianshu.io/upload_images/2349677-70fc70c77788ccc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p><strong>优势：速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本，而目前我们使用的虚拟机Sun HotSpot就是使用第二种方式进行对象访问的</strong></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运行时内存区域划分&quot;&gt;&lt;a href=&quot;#运行时内存区域划分&quot; class=&quot;headerlink&quot; title=&quot;运行时内存区域划分&quot;&gt;&lt;/a&gt;运行时内存区域划分&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java源文件(&lt;code&gt;.java文件&lt;/code&gt;)
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之使用Java函数式接口</title>
    <link href="http://yoursite.com/2019/01/21/Kotlin/Kotlin%E4%B9%8B%E4%BD%BF%E7%94%A8Java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/01/21/Kotlin/Kotlin之使用Java函数式接口/</id>
    <published>2019-01-20T16:00:00.000Z</published>
    <updated>2019-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="把lambda当做参数传递给Java方法"><a href="#把lambda当做参数传递给Java方法" class="headerlink" title="把lambda当做参数传递给Java方法"></a>把lambda当做参数传递给Java方法</h1><p>可以把<code>lambda</code>传给任何期望函数式接口的方法</p><pre><code>&lt;!--Java--&gt;void postponeCompution(int delay,Runnable computation);</code></pre><p>在Kotlin中，可以调用它并把一个<code>lambda</code>作为实参传给它。编译器会自动把它转换成一个<code>Runnable</code>的实例：</p><pre><code>postponeCompution(1000){println(42)}</code></pre><p>通过显示地创建一个实现了<code>Runnable</code>的匿名对象也能达到同样的效果</p><pre><code>postponeCompution(1000,object:Runnable{        override fun run(){            println(42)        }})</code></pre><p>但这里有一点不一样，当你显示地声明对象时，每次调用都会创建一个新的实例。而使用<code>lambda</code>，如果<code>lambda</code>没有访问任何来自定义它的函数的变量，相应的匿名类实例可以在多次调用之间重用</p><pre><code>postponeCompution(1000){println(42) &lt;!--整个程序只会创建一个Runnable的实例--&gt;</code></pre><p>因此，完全等价的实现应该是下面这段代码中的显示<code>object</code>声明，它把<code>Runnable</code>实例存储在一个变量中，并且每次调用的时候都是用这个变量：</p><pre><code>val runnable = Runnable{ println(42) } &lt;!--编译成全局变量：程序中仅此一个实例--&gt;fun handleCompution(){    postponeCompution(1000,runnable) &lt;!--每次postponeCompution调用时用的是一个对象--&gt;}</code></pre><p>如果<code>lambda</code>从包围它的作用域中捕捉了变量，每次调用就不再可能重用同一个实例了。这种情况下，每次调用时编译器都会创建一个新对象</p><pre><code>fun handleCompution(id:String){ &lt;!--lambda捕捉id这个变量--&gt;    postponeCompution(1000){println(id)} &lt;!--每次handleCompution调用时都会创建一个Runnable的新实例--&gt;}</code></pre><h1 id="SAM构造方法：显示地把lambda转换为函数式接口"><a href="#SAM构造方法：显示地把lambda转换为函数式接口" class="headerlink" title="SAM构造方法：显示地把lambda转换为函数式接口"></a>SAM构造方法：显示地把lambda转换为函数式接口</h1><p><code>SAM</code>构造方法是编译器生成的函数，让你执行从<code>lambda</code>到函数式接口实例的显示转换。如果一个方法返回的是一个函数是接口的实例，不能直接返回一个<code>lambda</code>，要用<code>SAM</code>构造方法把它包装起来</p><pre><code>fun createAllDoneRunnable() : Runnable{    return Runnable{ println(&quot;All done!&quot;) }}</code></pre><p><code>SAM</code>构造方法只接收一个参数：一个被用作函数式接口单抽象方法体的<code>lambda</code>，并返回实现这个接口的类的一个实例</p><pre><code>val listener = OnClickListener { view -&gt;    val text = when(view.id){        R.id.button1 -&gt; &quot;First button&quot;        R.id.button2 -&gt; &quot;Second button&quot;        else -&gt; &quot;Unknow Button&quot;    }    toast(text)}button1.setOnClickListener(listener)button2.setOnClickListener(listener)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;把lambda当做参数传递给Java方法&quot;&gt;&lt;a href=&quot;#把lambda当做参数传递给Java方法&quot; class=&quot;headerlink&quot; title=&quot;把lambda当做参数传递给Java方法&quot;&gt;&lt;/a&gt;把lambda当做参数传递给Java方法&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之惰性集合操作：序列</title>
    <link href="http://yoursite.com/2019/01/19/Kotlin/Kotlin%E4%B9%8B%E6%83%B0%E6%80%A7%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/01/19/Kotlin/Kotlin之惰性集合操作：序列/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-01-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用集合函数比如<code>map</code>和<code>filter</code>。这些函数会及早的创建中间集合，也就是说每一步的中间结果都被存储在一个临时列表。而序列给了你另一种选择，可以让你避免创建这些临时的中间对象。如下一个例子：</p><pre><code>val peoples = listOf(Person(&quot;Alice&quot;,20),Person(&quot;Bob&quot;,31))peoples.map(Person::name).filter { it.startsWith(&quot;A&quot;) }</code></pre><p>上面的例子中<code>map</code>和<code>filter</code>都会返回一个列表，也就是说链式的调用会创建两个列表，如果源列表中只有两个元素，这不是什么问题，但如果有一百万个元素，(链式)调用就会变得十分低效。<br>为提高效率，可以把操作变成使用序列，而不是直接使用集合</p><pre><code>peoples.asReversed() &lt;!--把初始集合转换成序列--&gt;   .map ( People::name )  &lt;!--序列支持和集合一样的API--&gt;   .filter {it.startsWith(&quot;A&quot;) }   .toList() &lt;!--把结果序列转换回列表--&gt;</code></pre><p>Kotlin惰性集合操作的入口就是<code>Sequence</code>接口，它的强大之处就在于其操作的实现方式，序列中元素的求值是惰性的。因此可以使用序列高效地对集合元素执行链式操作，而不需要创建额外的集合来保存过程中产生的中间结果。<br>可以调用扩展函数<code>asSequence</code>把任意集合转换成序列，调用<code>toList</code>来做反向的转换</p><h1 id="中间和末端操作"><a href="#中间和末端操作" class="headerlink" title="中间和末端操作"></a>中间和末端操作</h1><p>序列操作分为两类：中间和末端。一次中间操作返回的是另一个序列，这个新序列知道如何变换原始序列中的元素。而一次末端操作返回的是一个结果 </p><p><img src="https://upload-images.jianshu.io/upload_images/2349677-7495f4baeb2e96ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt></p><p>中间操作始终是惰性的，看看下面这个缺少了末端操作的例子</p><pre><code>listOf(1,2,3,4).asSequence()    .map{print(&quot;map ($it)&quot;);it * it}    .filter { print(&quot;filter($it)&quot;);it % 2 == 0 }</code></pre><p>执行以上这段代码不会在控制台输出任何内容。这意味着<code>map</code>和<code>filter</code>变换被延期了，它们只有在获取结果的时候caihui被应用(即末端操作被调用的时候)</p><p>在使用<code>map</code>和<code>filter</code>进行变换时，先应用<code>filter</code>有助于减少变换的次数。如果<code>map</code>在前，每个元素都被变换。而如果<code>filter</code>在前，不合适的元素会被尽早地过滤掉且不会发生变换</p><h1 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h1><p>使用<code>generateSequence</code>函数创建序列，给定序列中的前一个元素，这个函数会计算下一个元素</p><pre><code>    val naturalNumbers = generateSequence(0){it + 1}val numberTo100 = naturalNumbers.takeWhile { it &lt;= 100 }println(numberTo100.sum()) &lt;!--在获取结果`sum`时，所有被推迟的操作都被执行--&gt;</code></pre><p>创建使用父目录的序列，如果元素的父元素和它的类型相同，你可能会对它的祖先组成的序列的物质感兴趣。下面的例子可以查询文件是否放在隐藏目录中，通过创建一个其父目录的序列并检查每个目录的属性来实现</p><pre><code>fun File.isInsideHiddenDirectory() =    generateSequence(this){ it.parentFile}.any{ it.isHidden }val file = File(&quot;/Users/svtk/.HiddenDir/a.txt&quot;)println(file.isInsideHiddenDirectory())</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用集合函数比如&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;filter&lt;/code&gt;。这些函数会及早的创建中间集合，也就是说每一步的中间结果都被存储在一个临时列表。而序列给了你另一种选择，可以让你避免创建这些临时的中间对象。如下一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之Lambda表达式和成员引用</title>
    <link href="http://yoursite.com/2019/01/18/Kotlin/Kotlin%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%88%90%E5%91%98%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/18/Kotlin/Kotlin之Lambda表达式和成员引用/</id>
    <published>2019-01-17T16:00:00.000Z</published>
    <updated>2019-01-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda介绍：作为函数参数的代码块"><a href="#Lambda介绍：作为函数参数的代码块" class="headerlink" title="Lambda介绍：作为函数参数的代码块"></a>Lambda介绍：作为函数参数的代码块</h1><p>用匿名内部类实现监听器</p><pre><code>&lt;!--Java--&gt;button.setOnClickListener(new OnClickListener(){       override       public void onClick(View view){          &lt;!-- 点击后执行的动作--&gt;       }    });</code></pre><p>现在用Kotlin的Lambda表达式来替换匿名内部类</p><pre><code>button.setOnClickListener{&lt;!--点击后执行的动作--&gt;}</code></pre><h1 id="Lambda和集合"><a href="#Lambda和集合" class="headerlink" title="Lambda和集合"></a>Lambda和集合</h1><p>先看一个例子</p><pre><code>data class Person(val name:String,val age:Int)</code></pre><p>然后创建一个Person集合，并找出集合中年龄最大的那个</p><pre><code>val list = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))println(list.maxBy{it.age})Person{name=Bob，age=31}</code></pre><p>如上使用了Kotlin的库函数，<code>maxBy</code>函数可以在任何集合上调用，且只需要一个实参：一个函数，指定比较哪个值来找到最大值，而花括号中的代码<code>{it.age}</code>就是实现了这个逻辑的<code>lambda</code></p><p>如果lambda刚好是属性的委托，可以用成员引用代替</p><pre><code>list.maxBy(Person::age)</code></pre><h1 id="Lambda表达式语句"><a href="#Lambda表达式语句" class="headerlink" title="Lambda表达式语句"></a>Lambda表达式语句</h1><p><img src="https://upload-images.jianshu.io/upload_images/2349677-829577c94c89a493.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt></p><p>还可以把<code>lambda</code>表达式存储在一个变量中</p><pre><code>val sum = { x:Int,y:Int -&gt; x+y }println(sum(1,2))</code></pre><p>还可以直接调用<code>lambda</code>表达式</p><pre><code>{println(42)}()</code></pre><p>但是这样的语法毫无可读性，也没有什么意义，如果你确实需要把一小段代码封闭在一个代码块中，可以使用库函数<code>run</code>来执行传给它的<code>lambda</code></p><pre><code>run { println(42) }</code></pre><p>再回到上面的例子</p><pre><code>val list = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))println(list.maxBy{it.age})</code></pre><p>如果不用简明的语法重写这个例子，你会得到下面的代码</p><pre><code>list.maxBy( { p:Person -&gt; p.age} )</code></pre><p>这个代码就一目了然了，花括号里面的代码片段是<code>lambda</code>表达式，把它作为实参传递给函数。这个<code>lambda</code>接受一个Person的参数并返回它的年龄</p><p>这个代码还可以简化，如果<code>lambda</code>表达式是函数调用的最后一个实参，它可以放到括号的外面</p><pre><code>list.maxBy(){ p:Person -&gt; p.age }</code></pre><p>当<code>lambda</code>是函数唯一的实参时，还可以去掉调用代码中的空括号</p><pre><code>list.maxBy { p:Person -&gt; p.age }</code></pre><p>省略<code>lambda</code>参数类型，和局部变量一样，如果<code>lambda</code>参数的类型可以被推导出来，你就不需要显示地指定它。这里以<code>maxBy</code>函数为例，其参数的类型始终和集合中元素的类型相同</p><pre><code>list.maxBy { p -&gt; p.age }</code></pre><p>使用默认参数类型，仅在实参名称没有显示地指定时这个默认的名称才会生成</p><pre><code>list.maxBy{ it.age }</code></pre><p><strong>注意：</strong> <code>it</code>约定能大大缩短你的代码，但你不应该滥用它。尤其在嵌套<code>lambda</code>的情况下，最后显示地声明每个<code>lambda</code>的参数。否则很难搞清楚<code>it</code>引用的到底是哪个值。</p><p>此外，<code>lambda</code>表达式还可以包含更多的语句</p><pre><code>val sum = { x:Int,y:Int -&gt;     println(&quot;Computing the sum of $x and $y...&quot;)    x+y}println(sum(1,2)Computing the sum of 1 and 2...3</code></pre><h1 id="在作用域中访问变量"><a href="#在作用域中访问变量" class="headerlink" title="在作用域中访问变量"></a>在作用域中访问变量</h1><p>当在函数中声明一个匿名内部类的时候，在匿名内部类中可以引用函数的参数和局部变量。如果函数内部使用<code>lambda</code>，也可以访问这个函数的参数</p><pre><code>fun printMessageWithPrefix(messages:Collec    tion&lt;String&gt;,prefix:String){        messages.forEach {&lt;!--接收lambda作为实参--&gt;        println(&quot;$prefix $it&quot;) &lt;!--在lambda中访问prefix参数--&gt;    }}</code></pre><p>这里Kotlin和Java的区别就是，在Kotlin中不会仅限于访问<code>final</code>变量，在<code>lambda</code>内部也可以修改这些变量</p><h1 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用"></a>成员引用</h1><p>如果你想要当做参数传递的代码已经被定义成了函数，那么你可以将这个函数转换成值，如下使用<code>::</code>运算符来转换</p><pre><code>val getAge = Person::age</code></pre><p>这种表达式被称为成员引用，它提供简明语法，来创建一个调用单个方法或这访问单个属性的函数值。双冒号把类名称和你要引用的成员名称隔开</p><p><img src="https://upload-images.jianshu.io/upload_images/2349677-d33319b76370bf2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>如下这个<code>lambda</code>表达式</p><pre><code>val getAge = { person:Person -&gt; person.age }</code></pre><p>成员引用和调用函数的<code>lambda</code>具有一样的类型，所以可以相互转换</p><pre><code>list.maxBy(Person::age)</code></pre><p>还可以引用顶层函数，这种情况省略了类名称，直接以<code>::</code>开头。成员引用<code>::salute</code>被当作实参传递给库函数<code>run</code></p><pre><code>fun salute() = println(&quot;Salute!&quot;)run (::salute)Salute!</code></pre><p>如果<code>lambda</code>要委托给一个接收多个参数的函数，提供成员引用代替它将会非常方便</p><pre><code>val action = {person:Person,message:String -&gt; sendEmail(person,message)}val nextAction = ::sendEmail调用nextAction(...,...)</code></pre><p>可以用构造方法引用存储或者延期执行创建类实例的动作，构造方法的引用方式是在双冒号后指定类名称</p><pre><code>val createPerson = ::Person &lt;!--创建`Person`实例的动作被保存成了值--&gt;val person = createPerson(&quot;kdp&quot;,25)println(person)</code></pre><p>还可以使用同样的方式引用扩展函数</p><pre><code>fun Person.isAdult() = age &gt;= 21val predicate = Person::isAdult</code></pre><h1 id="绑定引用"><a href="#绑定引用" class="headerlink" title="绑定引用"></a>绑定引用</h1><p>Kotlin1.1允许你使用成员引用语法捕捉特定实例对象上的方法引用</p><pre><code>val p = Person(&quot;Dmitry&quot;,34)val dmitrysAgeFunction = p::ageprintln(dmitrysAgeFunction())</code></pre><blockquote><p>注意：dmitrysAgeFunction是一个零函数的参数，在Kotlin1.1之前，你需要显示地写出<code>lambda{p.age}</code>，而不是使用绑定成员引用<code>p::age</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lambda介绍：作为函数参数的代码块&quot;&gt;&lt;a href=&quot;#Lambda介绍：作为函数参数的代码块&quot; class=&quot;headerlink&quot; title=&quot;Lambda介绍：作为函数参数的代码块&quot;&gt;&lt;/a&gt;Lambda介绍：作为函数参数的代码块&lt;/h1&gt;&lt;p&gt;用匿
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之Object关键字：将声明一个类与创建一个实例结合起来</title>
    <link href="http://yoursite.com/2019/01/17/Kotlin/Kotlin%E4%B9%8BObject%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A%E5%B0%86%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5/"/>
    <id>http://yoursite.com/2019/01/17/Kotlin/Kotlin之Object关键字：将声明一个类与创建一个实例结合起来/</id>
    <published>2019-01-16T16:00:00.000Z</published>
    <updated>2019-01-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象声明：创建单例易如反掌"><a href="#对象声明：创建单例易如反掌" class="headerlink" title="对象声明：创建单例易如反掌"></a>对象声明：创建单例易如反掌</h1><p>Kotlin使用对象声明功能能将类声明与该类的单一实例声明结合到一起。需要注意的是对象声明可以包含属性、方法、初始化语句块等的声明，唯一不允许的就是构造方法。</p><pre><code>object Payroll{    val allEmployee = arrayListOf&lt;Person&gt;()    fun caculateSalary(){        for (person in allEmployee){        ...        }}}Payroll.allEmployee.add(Person(&quot;kdp&quot;,20))Payroll.caculateSalary()</code></pre><p>对象声明同样可以继承类和接口</p><pre><code>object CaseInsensitiveFileComparator : Comparator&lt;File&gt;{    override fun compare(o1: File, o2: File): Int = o1.path.compareTo(o2.path,true)}</code></pre><p>同样也可以在类中声明对象</p><h1 id="伴生对象：工厂方法和静态成员"><a href="#伴生对象：工厂方法和静态成员" class="headerlink" title="伴生对象：工厂方法和静态成员"></a>伴生对象：工厂方法和静态成员</h1><p>在类中定义的对象可以使用一个特殊的关键字来标记：<code>companion</code>。这样就可以直接通过容器类名称来访问这个对象的方法和属性。不需要显示的指明对象的名称。有点类似于Java中的静态方法的调用</p><pre><code>class A{    companion object {        fun bar(){        println(&quot;This is a bar!&quot;)        }    }}A.bar()</code></pre><p>伴生对象可以访问类中的所有private成员，包括private构造方法</p><pre><code>class User private constructor(val nickname:String){    companion object{        fun newSubscribingUser(email: String) = User(email.substringBefore(&apos;@&apos;))        fun newFacebookUser(account:String) = User(&quot;facebook&quot;)    }}val subscribing = User3.newSubscribingUser(&quot;Subscribing&quot;)val faceBook = User3.newFacebookUser(&quot;Facebook&quot;)println(subscribing.nickname)println(faceBook.nickname)</code></pre><h1 id="在伴生对象中实现接口"><a href="#在伴生对象中实现接口" class="headerlink" title="在伴生对象中实现接口"></a>在伴生对象中实现接口</h1><pre><code>interface JSONFactory&lt;T&gt;{    fun fromJSON(jsonStr:String) : T}class Person(val name:String){    companion object : JSONFactory&lt;Person&gt;{        override fun fromJSON(jsonStr: String) : Person = ...    }}fun &lt;T&gt;loadFromJSON (fact:JSONFactory&lt;T&gt;) : T = fact.fromJSON(&quot;kdp&quot;)loadFromJSON(Person) &lt;!--将伴生对象实例传给它--&gt;注意：Person类的名字被当做JSONFactory的实例</code></pre><h1 id="伴生对象扩展"><a href="#伴生对象扩展" class="headerlink" title="伴生对象扩展"></a>伴生对象扩展</h1><p>伴生对象同样可以用到扩展函数上</p><pre><code>class Person(val firstName:String,val lastName:String){    companion object{}}fun Person.Companion.fromJSON(json:String): Person{...} &lt;!--声明一个扩展函数--&gt;val p = Person.fromJSON(json)</code></pre><h1 id="对象表达式：改变写法的匿名内部类"><a href="#对象表达式：改变写法的匿名内部类" class="headerlink" title="对象表达式：改变写法的匿名内部类"></a>对象表达式：改变写法的匿名内部类</h1><p>使用匿名内部类实现事件监听</p><pre><code>window.addMouseListener{    object : MouseAdapter(){        override fun mouseClicked(e:MouseEvent){            ...        }        override fun mouseEntered(e:MouseEvent){            ...        }    }}</code></pre><p>除了去掉了对象的名称外，语法和对象声明是相同的，对象表达式声明了一个类并创建了该类的一个实例。</p><p>可以给对象分配一个名字，将其存储在一个变量中</p><pre><code>val listener = object : MouseAdapter(){        override fun mouseClicked(e:MouseEvent){            ...        }        override fun mouseEntered(e:MouseEvent){            ...        }    }</code></pre><p>与Java匿名内部类不同的是：Kotlin的匿名对象可以实现多个接口或者不实现接口</p><p><strong>注意</strong>: 与对象声明不同，匿名对象不是单例的。每次对象表达式被执行都被创建一个新的实例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象声明：创建单例易如反掌&quot;&gt;&lt;a href=&quot;#对象声明：创建单例易如反掌&quot; class=&quot;headerlink&quot; title=&quot;对象声明：创建单例易如反掌&quot;&gt;&lt;/a&gt;对象声明：创建单例易如反掌&lt;/h1&gt;&lt;p&gt;Kotlin使用对象声明功能能将类声明与该类的单一实
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之通用对象方法、数据类和委托类</title>
    <link href="http://yoursite.com/2019/01/16/Kotlin/Kotlin%E4%B9%8B%E9%80%9A%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E5%A7%94%E6%89%98%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/01/16/Kotlin/Kotlin之通用对象方法、数据类和委托类/</id>
    <published>2019-01-15T16:00:00.000Z</published>
    <updated>2019-01-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用对象方法"><a href="#通用对象方法" class="headerlink" title="通用对象方法"></a>通用对象方法</h1><p>声明一个类，用来存储客户名称和邮编</p><pre><code>class Client(val name:String,val postalCode:Int)</code></pre><ul><li><p><strong>字符串表示 : toString()</strong></p><p>  默认的话，一个对象的字符串表示形如<code>Client@5e9f23b4</code>，这并不十分有用，要想改变它，需要重写<code>toString()</code>方法</p><p>  为<code>Client</code>实现<code>toString()</code></p><pre><code>class Client(val name:String,val postalCode:Int){    override fun toString(): String {        return &quot;Client(name = $name postalCode = $postalCode)&quot;    }}</code></pre><p>  输出如下</p><pre><code>Client(name = 康栋普 postalCode = 123456)</code></pre></li><li><p><strong>对象相等性 ：equals()</strong></p><p>  假如想要将包含相等数据的对象视为相等</p><pre><code>&lt;!----&gt;val client1 = Client(&quot;康栋普&quot;,123456)val client2 = Client(&quot;康栋普&quot;,123456)println(client1 == client2) &lt;!--在Kotlin中，==检查对象是否相等，而不是比较引用，这里会编译成调用`equals`--&gt;false注意:- 在Java中，可以使用==运算符来比较基本数据类型和引用类型。在基本数据上，==比较的是值；然而在引用类型上，==比较的是引用(引用指向的地址)- 在Kotlin中，==运算符是比较两个对象的默认方式。本质上说它是通过equals方法来比较两个值的。所以如果你的equals在类中重写了，你能够很安全地使用==来比较实例。要想进行引用比较，可以使用===运算符，它与Java中的==比较对象引用是一样的</code></pre></li><li><p><strong>Hash容器 ：hashCode()</strong></p><p>  <code>hashCode</code>方法通常与<code>equals</code>一起被重写，它主要用来底层数据结果是<code>hash table</code>，例如: <strong>HashSet、HashMap、HashTable</strong><br>  如果两个对象相等，它们的<code>hash</code>值也必须相等；一般在比较对象的时候会先去比较它们的<code>hash</code>值，如果不相等，那么对象就不相等；如果<code>hash</code>值相等，再使用<code>equals</code>去比较值。</p></li></ul><h1 id="数据类-自动实现通用方法"><a href="#数据类-自动实现通用方法" class="headerlink" title="数据类:自动实现通用方法"></a>数据类:自动实现通用方法</h1><p>如果想要你的类是一个方便的数据容器,你需要重写这些方法: <code>toString、equals和hashCode</code>。而在Kotlin中你不需要再去生成这些方法了，给你的类添加<code>data</code>修饰符，必要的方法将会自动生成</p><pre><code>data class Client(val name:String,val postalCode:Int)</code></pre><p>现在就得到了一个重写了所有标准Java方法的类</p><ul><li>equals用来比较实例</li><li>hashCode用来作为例如HashMao这种基于哈希容器的键</li><li>toString用来为类生成按声明顺序排列的所有字段的字符串表达式</li></ul><p>数据类和不可变性：copy()方法</p><p>在数据类中，如果属性使用<code>val</code>，在对象被创建出来时，对象内部的值是无法改变的。为了让不可变数据的数据类可以变得更容易，Kotlin给它们提供了一个方法：一个允许<code>copy</code>类的实例的方法，并在<code>copy</code>的同时修改某些属性的值</p><p>下面为手动实现`copy方法</p><pre><code>  class Client(val name:String,val postalCode:Int){  fun copy(name:String = this.name,postalCode: Int = this.postalCode) = Client(name,postalCode)}val client = Client(&quot;kangdongpu&quot;,123456)println(client.copy(&quot;kdp123&quot;))</code></pre><p>输出</p><pre><code>Client(name=kdp123, postalCode=123456)</code></pre><h1 id="委托类：使用by关键字"><a href="#委托类：使用by关键字" class="headerlink" title="委托类：使用by关键字"></a>委托类：使用<code>by</code>关键字</h1><p>例如要实现一个如<code>Collection</code>接口的装饰器，那么你需要实现它内部的所有方法，即使你不做任何行为的修改</p><pre><code>class DelegatingCollection&lt;T&gt; : Collection&lt;T&gt;{    override val size: Int        get() = this.size    override fun contains(element: T): Boolean = this.contains(element)    override fun containsAll(elements: Collection&lt;T&gt;): Boolean = this.containsAll(elements)    override fun isEmpty(): Boolean = this.isEmpty()    override fun iterator(): Iterator&lt;T&gt; = this.iterator()}</code></pre><p>而现在Kotlin将委托作为一个语言级别的的功能做了头等支持。无论什么时候实现一个接口，你都可以使用<code>by</code>关键字将接口的实现委托到另一个对象</p><pre><code>class DelegatingCollection&lt;T&gt; (innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; by innerList{}</code></pre><p>类中所有的方法实现都消失了，编译期会自动实现它们，并且方法的实现和上面的<code>DelegatingCollection</code>的例子是相似的，而当你需要修改某些方法的行为时，再去重写这些方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通用对象方法&quot;&gt;&lt;a href=&quot;#通用对象方法&quot; class=&quot;headerlink&quot; title=&quot;通用对象方法&quot;&gt;&lt;/a&gt;通用对象方法&lt;/h1&gt;&lt;p&gt;声明一个类，用来存储客户名称和邮编&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Client(val name
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之构造方法或属性的类</title>
    <link href="http://yoursite.com/2019/01/14/Kotlin/Kotlin%E4%B9%8B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/01/14/Kotlin/Kotlin之构造方法或属性的类/</id>
    <published>2019-01-13T16:00:00.000Z</published>
    <updated>2019-01-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主构造方法和初始化语句块"><a href="#主构造方法和初始化语句块" class="headerlink" title="主构造方法和初始化语句块"></a>主构造方法和初始化语句块</h1><p>声明一个主构造方法</p><pre><code>class User constructor(_nickname: String){&lt;!-- 带一个参数的主构造方法--&gt;    val nickname: String    init { &lt;!--初始化语句块--&gt;        nickname = _nickname    }}</code></pre><p>在上面的例子中，由于主构造方法中有限制，不能包含初始化代码，因此需要使用初始化语句块。</p><p>在这个例子中，也可以去掉<code>constructor</code>关键字</p><pre><code>class User2 constructor(_nickname: String){    val nickname = _nickname}</code></pre><p>如果属性用相应的构造方法参数来初始化，代码可以通过把<code>val</code>关键字加在参数前的方式来进行简化，这样就可以替换类中的属性定义</p><pre><code>class User(val nickname:String)</code></pre><p>可以向函数参数一样为构造方法参数声明默认值</p><pre><code>class User(val nickname: String,val isSubscribed: Boolean = true)</code></pre><p>如果一个类中具有父类，主构造方法中同样需要初始化父类</p><pre><code>open class User(val nickname: String){...}class TwitterUser(name:String) : User(name){...}</code></pre><p>如果父类没有提供任何的构造方法，必须显示地调用父类的构造方法，即使它没有任何的参数</p><pre><code>open class Buttonclass RadioButton : Button()</code></pre><p>不要让类外部的代码实例化它，可以将构造方法标记为<code>private</code></p><pre><code>class Secretive private constructor(){...}</code></pre><h1 id="用不同的方式初始化父类"><a href="#用不同的方式初始化父类" class="headerlink" title="用不同的方式初始化父类"></a>用不同的方式初始化父类</h1><p>当需要重写父类多个构造方法时，需要声明多个从构造方法</p><pre><code>class MyButton : View{    constructor(ctx:Context):this(ctx, null)&lt;!--调用自己的构造方法--&gt;    constructor(ctx: Context,attr: AttributeSet?):super(ctx,attr) &lt;!--调用父类的构造方法--&gt;}    </code></pre><h1 id="实现在接口中声明的属性"><a href="#实现在接口中声明的属性" class="headerlink" title="实现在接口中声明的属性"></a>实现在接口中声明的属性</h1><pre><code>interface User {    val nickname: String}</code></pre><ul><li><p>在子类的主构造方法的参数前面加上<code>override</code>关键字，表明这个属性实现了来自于父类<code>User</code>的抽象属性</p><pre><code>class PrivateUser(override val nickname: String) : User </code></pre></li></ul><ul><li><p><code>nickname</code>属性通过自定义<code>getter</code>的方式来实现</p><pre><code>class SubscribingUser(val email: String) : User {    override val nickname: String        get() = email.substringBefore(&quot;@&quot;)}</code></pre></li><li>在初始化时将<code>nickname</code>属性与值关联的方式来实现</li></ul><pre><code>class FaceBookUser(val accountId：Int) : User {    override val nickname = getFacebookName(accountId)}</code></pre><p>除了抽象属性声明外，接口还可以包含具有<code>getter</code>和<code>setter</code>的属性</p><pre><code>interface User {    val email: String    val nickname: String        get() = email.substringBefore(&quot;@&quot;)}</code></pre><p>这个接口包含抽象属性<code>email</code>，同时<code>nickname</code>属性有一个自定义的<code>getter</code>。第一个属性必须在子类中重写，第二个属性是可以被继承的。</p><h1 id="通过getter或setter访问支持字段"><a href="#通过getter或setter访问支持字段" class="headerlink" title="通过getter或setter访问支持字段"></a>通过<code>getter</code>或<code>setter</code>访问支持字段</h1><p>声明一个可变属性，并且在每次<code>setter</code>访问时执行额外的代码</p><pre><code>class User(val name: String){    var address: String = &quot;unspecified&quot;        set(value) {            println(&quot;Address was changed for $name: $address -&gt; $value&quot;) &lt;!--读取支持字段的值--&gt;            field = value &lt;!--更新支持字段的值--&gt;        }}val user = User(&quot;kangdongpu&quot;);user.address = &quot;HeBei,SJZ&quot;&lt;!--输出--&gt;Address was changed for kangdongpu: unspecified -&gt; HeBei,SJZ</code></pre><p>在<code>setter</code>的函数体中，使用了特殊的标识符<code>field</code>来访问支持字段的值。在<code>getter</code>中，只能读取值；而在<code>setter</code>中，即能读取也能修改它</p><h1 id="修改访问器的可见性"><a href="#修改访问器的可见性" class="headerlink" title="修改访问器的可见性"></a>修改访问器的可见性</h1><p>声明一个具有<code>private setter</code>的属性，让其不能在类外部被修改</p><pre><code>class LengthCounter {    var counter:Int = 0    private set &lt;!--不能在类外部修改此属性值，将setter的可见性改为private--&gt;    fun addWord(word:String){&lt;!--可在类内部通过方法修改--&gt;        counter+=word.length    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主构造方法和初始化语句块&quot;&gt;&lt;a href=&quot;#主构造方法和初始化语句块&quot; class=&quot;headerlink&quot; title=&quot;主构造方法和初始化语句块&quot;&gt;&lt;/a&gt;主构造方法和初始化语句块&lt;/h1&gt;&lt;p&gt;声明一个主构造方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之类继承结构</title>
    <link href="http://yoursite.com/2019/01/10/Kotlin/Kotlin%E4%B9%8B%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/01/10/Kotlin/Kotlin之类继承结构/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>使用<code>interface</code>关键字来声明一个接口</p><pre><code>interface Clickable{    fun click()}</code></pre><p>接下来实现这个接口</p><pre><code>class Button : Clickable{    override fun click() = println(&quot;I was clicked&quot;)}</code></pre><p>Kotlin中使用冒号代替了Java中的<code>extends</code>和<code>implements</code>关键字。和Java一样，一个类可以实现多个任意接口，但只能继承一个类</p><p>与Java中的<code>@Override</code>注解类似，<code>override</code>修饰符用来标注被重写的父类的接口的方法和属性。</p><p>接口可以有一个默认的实现，当然也可以在子类中重新定义<code>showOff</code>函数的实现</p><pre><code>interface Clickable{    fun click()    fun showOff() = println(&quot;I&apos;m clickable!&quot;) //带默认实现的方法}</code></pre><p>定义另一个实现了同样方法的接口</p><pre><code>interface Focusable{    fun setFocus(b:Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lose&quot;} focus&quot;)    fun showOff() = println(&quot;I&apos;m focusable!&quot;)}</code></pre><p>然后在一个子类中同时实现这两个接口，它们每一个都包含了带默认实现的<code>showOff</code>方法，那么子类中你必须要实现这个方法，在Java中可以把基类的名字放在<code>super</code>关键字的前面；但是在Kotlin中需要把基类的名字放在尖括号中</p><pre><code>class Button2 : Clickable,Focusable{override fun showOff() {    super&lt;Clickable&gt;.showOff()    super&lt;Focusable&gt;.showOff()}override fun click() {}</code></pre><p>}</p><p><strong>注意</strong>：在Java中实现Kotlin的接口，Java并不支持接口中的默认方法，子类必须实现方法体</p><h1 id="open、final和abstract修饰符-默认为final"><a href="#open、final和abstract修饰符-默认为final" class="headerlink" title="open、final和abstract修饰符:默认为final"></a>open、final和abstract修饰符:默认为final</h1><p>声明一个带<code>open</code>的<code>open</code>类</p><pre><code>open class RichButton : Clickable{ //这个类是open的:其他类可以继承它    override fun click() {}//这个函数重写了一个open函数并且它本身同样是open的    fun disable(){} //这个函数是final的：不能在子类中重写它    open fun animate(){}//这个函数是open的：可以在子类中重写它}</code></pre><p><strong>注意</strong>：如果你重写了一个基类或者接口的成员，重写了的成员同样默认是<code>open</code>的。如果你想阻止你类的子类重写你的实现，可以显示地将重写的成员标注为<code>final</code></p><pre><code>open class RichButton: Clickable {    final override fun click(){}}</code></pre><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>在Kotlin中，与Java一样，可以将一个类声明成<code>abstract</code>的，这种类不能被实例化。并且它内部的抽象成员始终是<code>open</code>的，因此不需要显示地使用<code>open</code>修饰符</p><pre><code>abstract class Animated{    abstract fun animate()    open fun stopAnimating(){}    fun animateTwice(){}}</code></pre><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><ul><li>访问修饰符<br><br>普通类中成员默认为<code>final</code>;接口、抽象类中成员默认为<code>open</code>;若子类继承的父类方法为<code>open</code>，那么子类重写后的方法也为<code>open</code></li></ul><table><thead><tr><th>修饰符</th><th>相关成员</th><th>评注</th></tr></thead><tbody><tr><td>final</td><td>不能被重写</td><td>类中成员默认使用</td></tr><tr><td>open</td><td>可以被重写</td><td>需要明确的表明</td></tr><tr><td>abstract</td><td>必须被重写</td><td>只能在抽象类中使用;抽象成员不能有实现</td></tr><tr><td>override</td><td>重写父类或接口中的成员</td><td>如果没有使用final表明,重写的成员默认是开放的</td></tr></tbody></table><ul><li>可见性修饰符(默认为<code>public</code>)</li></ul><table><thead><tr><th>修饰符</th><th>类成员</th><th>顶层声明</th></tr></thead><tbody><tr><td>public(默认)</td><td>所有地方可见</td><td>所有地方可见</td></tr><tr><td>internal</td><td>模块中可见</td><td>模块中可见</td></tr><tr><td>protected</td><td>子类中可见</td><td>————</td></tr><tr><td>private</td><td>类中可见</td><td>文件中可见</td></tr></tbody></table><h1 id="内部类和嵌套类"><a href="#内部类和嵌套类" class="headerlink" title="内部类和嵌套类"></a>内部类和嵌套类</h1><p>Kotlin没有显示的嵌套类与Java中的<code>static</code>嵌套类一样，要把它变成内部类来持有一个外部类的引用要用<code>inner</code>，下面是Java和Kotlin在这个行为上的不同：</p><table><thead><tr><th>类A在另一个类B中声明</th><th>在Java中</th><th>在Kotlin中</th></tr></thead><tbody><tr><td>嵌套类(不存储外部类的引用)</td><td>static class A</td><td>class A</td></tr><tr><td>内部类(存储外部类的引用)</td><td>class A</td><td>inner class A</td></tr></tbody></table><h1 id="密封类-定义受限的类继承结构"><a href="#密封类-定义受限的类继承结构" class="headerlink" title="密封类:定义受限的类继承结构"></a>密封类:定义受限的类继承结构</h1><p>在使用<code>when</code>表达式时，Kotlin编译期会强制检查默认选项。所以不得不添加一个默认的分支。Kotlin为这个问题提供了一个解决方案：<code>sealed</code>类。为父类添加一个<code>sealed</code>修饰符，对可能创建的子类做出严格的限制，所有的直接子类都必须嵌套在父类中</p><pre><code> sealed class Expr  //将基类标记成密封的，sealed修饰符隐含的是open的{    class Num(val value:Int) : Expr()   //将所有可能的类作为嵌套类    class Sum(val left:Expr,val right:Expr) : Expr()}fun simplifyEval2(e:Expr):Int =    when(e){// “when”表达式涵盖了所有可能的情况，所以不再需要“else”分支       is Expr.Num -&gt;            e.value       is Expr.Sum -&gt;            simplifyEval2(e.left) + simplifyEval2(e.right)    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h1&gt;&lt;p&gt;使用&lt;code&gt;interface&lt;/code&gt;关键字来声明一个接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface Clickable{
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之可变参数、中缀调用和解构声明</title>
    <link href="http://yoursite.com/2019/01/08/Kotlin/Kotlin%E4%B9%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E3%80%81%E4%B8%AD%E7%BC%80%E8%B0%83%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%84%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2019/01/08/Kotlin/Kotlin之可变参数、中缀调用和解构声明/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2019-01-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>当你调用一个函数创建列表时，可以传递任意个数的参数给它：</p><pre><code>val list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)</code></pre><p>点进<code>listOf</code>方法内部你会发现</p><pre><code>public fun &lt;T&gt; listOf(vararg elements: T): List&lt;T&gt; {...}</code></pre><p>你可能对Java中的可变参数已经很熟悉了。Kotlin的可变参数与Java类似，但语法略有不同：</p><ul><li>Kotlin在该类型后不会再使用三个点，而是在参数上使用<code>vararg</code>修饰符</li><li>当需要传递的参数已经被包装到数组中。在Java中可以按照原样传递数组；而在Kotlin中要求你显示的解包数组，以便每个数组元素能够在函数中作为单独的参数来调用，不过需要再对应的参数前面加一个<code>*</code></li></ul><h1 id="中缀调用、解构声明"><a href="#中缀调用、解构声明" class="headerlink" title="中缀调用、解构声明"></a>中缀调用、解构声明</h1><p>先看一个例子，使用<code>mapOf</code>函数创建一个<code>map</code></p><pre><code>val map = mapOf(1 to &quot;a&quot;,2 to &quot;b&quot;,3 to &quot;c&quot;)</code></pre><p>这段代码中的单词<code>to</code>不是内置结构，而是一种特殊的函数调用，被称为<strong>中缀调用</strong>。</p><p>以下这两种方式是等价的：</p><pre><code>&quot;A&quot;.to(1) //一般to函数的调用&quot;A&quot; to 1 //使用中缀符号调用to函数</code></pre><p>中缀函数可以与只有一个参数的函数一起使用，并且普通函数和扩展函数都可以使用。<code>to</code>函数会返回一个<code>Pair</code>类型的对象</p><pre><code>infix fun Any.to(other:Any) = Pair(this,other)</code></pre><p>可以直接使用<code>Pair</code>的内容来初始化两个变量，这个功能被称为<strong>解构声明</strong></p><pre><code>val (number,name) = 1 to &quot;one&quot;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/2349677-c151bc84a169ba7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>用<strong>to</strong>函数创建一个<strong>pair</strong>，然后用解构声明来展开</p><p>也适用于循环，例如使用<code>withIndex</code>函数的实现</p><pre><code>val list = listOf(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;)for ((key,value) in list.withIndex())    println(&quot;key = $key   value = $value&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;可变参数&quot;&gt;&lt;a href=&quot;#可变参数&quot; class=&quot;headerlink&quot; title=&quot;可变参数&quot;&gt;&lt;/a&gt;可变参数&lt;/h1&gt;&lt;p&gt;当你调用一个函数创建列表时，可以传递任意个数的参数给它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val list = listOf(
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之扩展函数和属性</title>
    <link href="http://yoursite.com/2019/01/07/Kotlin/Kotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/01/07/Kotlin/Kotlin之扩展函数和属性/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义扩展函数"><a href="#定义扩展函数" class="headerlink" title="定义扩展函数"></a>定义扩展函数</h1><p>在系统的String类中添加一个扩展函数，例如获取字符串中最后一个字符(<strong>注意:扩展函数时声明在类之外的</strong>)</p><pre><code>//String为接收者类型          //this为接收者对象(this可以省略)fun String.lastChar() = this.get(this.length-1) //接收者类型是由扩展函数定义的，接收者对象是该类型的一个实例</code></pre><p>在Kotlin中调用它</p><pre><code>fun testLastChar(){    println(&quot;Kotlin&quot;.lastChar())}</code></pre><p>实际上扩展函数是静态函数，它把调用对象作为了第一个参数。调用这个静态函数，然后把接收者对象作为第一个参数传进来即可，假如它声明在一个叫做<code>StringUtils.kt</code>文件中，然后在Java中调用</p><pre><code>/*java*/char c = StringUtils.lastChar(&quot;Kotlin&quot;);System.out.println(&quot;lastIndex = &quot;+ c);</code></pre><p>在扩展函数中，可以直接访问被扩展的类的其他方法和属性，就好像是在这个类自己的方法中访问它们一样(<strong>注意：扩展函数不能访问私有的或者是受保护的成员</strong>)</p><h1 id="导入和扩展函数"><a href="#导入和扩展函数" class="headerlink" title="导入和扩展函数"></a>导入和扩展函数</h1><p>如果要在不同包中使用定义好的扩展函数，需要进行导入。Kotlin允许用和导入单个的函数</p><pre><code>import com.kdp.kotlin.lastCharval char = &quot;Kotlin&quot;.lastChar()</code></pre><p>也可以使用<code>*</code>来导入</p><pre><code>import com.kdp.kotlin.*val char = &quot;Kotlin&quot;.lastChar()</code></pre><p>可以使用关键字<code>as</code>来修改导入的类或者函数名称</p><pre><code>import com.kdp.kotlin.lastChar as lastval char = &quot;Kotlin&quot;.last()</code></pre><h1 id="作为扩展函数的工具类"><a href="#作为扩展函数的工具类" class="headerlink" title="作为扩展函数的工具类"></a>作为扩展函数的工具类</h1><p>现在可以写一个<code>joinToString</code>函数的终极版了，它和你在Kotlin标准库中看到的一模一样</p><pre><code>fun &lt;T&gt; Collection&lt;T&gt;.joinToString(separator:String=&quot;&quot;,prefix:String=&quot;&quot;,postfix:String=&quot;&quot;) : String{    val  result = StringBuilder(prefix)    for ((index,element) in this.withIndex()){        if (index &gt; 0) result.append(separator)            result.append(element)    }            result.append(postfix)        return result.toString()}</code></pre><p>测试</p><pre><code>fun test(){    val list = listOf(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;)    println( list.joinToString(&quot;,&quot;,&quot;(&quot;,&quot;)&quot;))}//输出:(A,B,C,D,E)</code></pre><h1 id="不可重写的扩展函"><a href="#不可重写的扩展函" class="headerlink" title="不可重写的扩展函"></a>不可重写的扩展函</h1><p>扩展函数并不是类的一部分，它是声明在类之外的，尽管可以给基类和子类都分别定义一个同名的扩展函数，当这个函数被调用时，它会用到哪一个函数呢?它由该变量的静态类型所决定的，而不是这个变量的运行时类型</p><h1 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h1><p>声明一个扩展属性，和扩展函数一样，扩展属性也像接收者的一个普通的成员属性一样，这里必须定义<code>getter</code>函数,因为没有支持字段，因此没有默认<code>getter</code>的实现。同理，初始化也不可以，没有地方存储初始化值</p><pre><code>val String.lastChar : Char    get() = get(this.length-1)</code></pre><p>可以像访问使用成员属性一样访问它</p><pre><code>println(&quot;Kotlin&quot;.lastChar)</code></pre><p>在Java中访问扩展属性需要显示的调用</p><pre><code>StringUtils.getLastChar(&quot;Java&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义扩展函数&quot;&gt;&lt;a href=&quot;#定义扩展函数&quot; class=&quot;headerlink&quot; title=&quot;定义扩展函数&quot;&gt;&lt;/a&gt;定义扩展函数&lt;/h1&gt;&lt;p&gt;在系统的String类中添加一个扩展函数，例如获取字符串中最后一个字符(&lt;strong&gt;注意:扩展函数时声明
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之让函数更好调用</title>
    <link href="http://yoursite.com/2019/01/07/Kotlin/Kotlin%E4%B9%8B%E8%AE%A9%E5%87%BD%E6%95%B0%E6%9B%B4%E5%A5%BD%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/07/Kotlin/Kotlin之让函数更好调用/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>声明一个函数:使用分隔符分割每一个元素</p><pre><code>fun &lt;T&gt; joinToString(collection: Collection&lt;T&gt;,separator:String,prefix:String,postfix:String) : String{    val result = StringBuilder(prefix)    for ((index,element) in collection.withIndex()){    if (index &gt; 0) result.append(separator)     result.append(element)    }        result.append(postfix)    return result.toString()}</code></pre><p>为了提高函数调用的可读性，当调用一个Kotlin定义的函数时，可以显示的标注一些参数的声明。如果在调用函数时，指明了一个参数的名称，那么它之后的所有参数都需要标明名称，就像下面这样(注意:当调用Java的函数时，不能采用命名参数)</p><pre><code>fun testJoinToString(){    val resutl = joinToString(collection = arrayListOf(&quot;10&quot;,&quot;20&quot;,&quot;50&quot;,&quot;80&quot;),separator = &quot;,&quot;,prefix = &quot;(&quot;,postfix = &quot;)&quot;)    println(resutl)}</code></pre><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h1><p>在声明函数的时候，指定参数的默认值，来避免创建重载的函数，修改<code>javaToString</code>函数的参数，如下</p><pre><code>fun &lt;T&gt; joinToString(collection: Collection&lt;T&gt;,separator:String = &quot;&quot;,prefix:String = &quot;&quot;,postfix:String = &quot;&quot;):String{    val result = StringBuilder(prefix)    for ((index,element) in collection.withIndex()){        if (index &gt; 0) result.append(separator)        result.append(element)    }        result.append(postfix)    return result.toString()}</code></pre><p>当使用常规的调用语句时，必须按照函数声明定义的参数顺序来给定参数，可以省略的只有排在末尾的参数</p><pre><code>fun testJoinToString(){    val list = listOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)    joinToString(list,&quot;&quot;,&quot;&quot;,&quot;&quot;)    joinToString(list,&quot;,&quot;,&quot;(&quot;)    joinToString(list)}</code></pre><p>如果使用命名参数，则可以省略中间的一些参数,也可以以你想要的任意顺序只给定你需要的参数</p><pre><code>fun testJoinToString(){    val list = listOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)    joinToString(list,prefix = &quot;(&quot;,postfix = &quot;)&quot;)}</code></pre><p>考虑到Java中没有参数默认值的概念，当从Java中调用Kotlin函数的时候，必须显示地指定所有参数值，<br>如果需要从Java代码中频繁的调用，而且希望它能对Java的调用更简洁，可以使用<code>@JvmOverloads</code>注解它。<br>这个注解表示编译期生成Java重载函数，从最后一个开始省略每个参数，就像这样</p><pre><code>@JvmOverloadsfun &lt;T&gt; joinToString(...):String{...}</code></pre><h1 id="消除静态工具类：顶层函数和属性"><a href="#消除静态工具类：顶层函数和属性" class="headerlink" title="消除静态工具类：顶层函数和属性"></a>消除静态工具类：顶层函数和属性</h1><p>在Java中，如果有很多公共的函数，我们一般需要创建一个公共类，如下</p><pre><code>package com.kdp.java;public class JoinKt {    public static String joinToString(...){    ...    }}</code></pre><p>但是在Kotlin中，根本不需要创建这些无意义的类。你可以将这些函数直接放到代码文件的顶层，不用从属任何类。<br>这些放到文件顶层的函数依然是包内的成员,此时还需要改变包含Kotlin顶层函数的生成的类的名称<br>需要为这个文件添加<code>@JvmName</code>的注解，将其放到这个文件的开头，位于包名的前面</p><pre><code>@file:JvmName(&quot;AppUtils&quot;)   //注解指定类名package com.kdp.kotlin //包的声明跟在文件注解之后fun joinToString(...):String{...}</code></pre><p>然后在Java中这样调用</p><pre><code>/*java*/import com.kdp.kotlin.AppUtils;public class Test {    public static void main(String[] args){        AppUtils.joinToString(...);    }}</code></pre><p>顶层属性，和函数一样，属性也可以放到文件的顶层，如下用var属性来计算一些函数被执行的次数</p><pre><code>var opCount = 0; //声明一个顶层属性fun performOperation(){    opCount++      //改变该属性的值}fun reportOperationCount(){    println(opCount) //读取该属性值}</code></pre><p>像上面的<code>opCount</code>值会被存储在i个静态的字段中，也可以在代码中用顶层属性来定义常量</p><pre><code>val UNIX_LINE_SEPARTOR = &quot;\n&quot;</code></pre><p>顶层属性可以通过访问器暴露给Java使用(如果是val就只有一个getter,如果是val就对应一对getter和setter)</p><pre><code>/*java*/AppUtils.getUNIX_LINE_SEPARTOR()</code></pre><p>把一个常量以<code>public static final</code>的属性暴露给Java，可以使用<code>const</code>来修饰它</p><pre><code>/*kotlin*/const val UNIX_LINE_SEPARTOR = &quot;\n&quot;</code></pre><p>等同于下面的Java代码</p><pre><code>/*java*/public static final String UNIX_LINE_SEPARTOR = &quot;\n&quot;;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;声明一个函数:使用分隔符分割每一个元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun &amp;lt;T&amp;gt; joinToString(collection: Collection&amp;lt;T&amp;gt;,separator:String,prefix:String,postfix:Stri
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之创建集合</title>
    <link href="http://yoursite.com/2019/01/06/Kotlin/Kotlin%E4%B9%8B%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/01/06/Kotlin/Kotlin之创建集合/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>创建不可变的List集合,list引用不能通过 list[0] = “4” 这样的方式修改集合中的内容，尽管<code>listOf</code>返回的是一个<code>ArrayList</code>集合，但它不能改变对象内部的值</p><pre><code>var list = listOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)</code></pre><p>创建一个可变的arrayList集合,可修改集合内部的值，如下修改集合中第0个元素的内容，然后分别打印出修改前后的集合</p><pre><code>val arrayList = arrayListOf(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)    println(&quot;修改前 ${arrayList}&quot;)    arrayList[0] = &quot;0&quot;    println(&quot;修改后 ${arrayList}&quot;)打印    修改前 [1, 2, 3]    修改后 [0, 2, 3]</code></pre><h1 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h1><p><code>Set</code>、<code>Map</code>和<code>List</code>一样，它们的<code>setOf</code>和<code>mapOf</code>方法分别返回的是不可变的集合对象，除此之外的方式创建的集合对象都是可变的</p><p>使用类似的方法创建<code>Set</code>和<code>Map</code>集合，当然还有很多不同的集合，它们的创建方式都类似，这里就不一一列举了</p><pre><code>val set = hashSetOf(1,7,53)val map = hashMapOf(1 to &quot;one&quot;,7 to &quot;seven&quot;,53 to &quot;fifty-three&quot;)//注意,to并不是一个特殊的结构，而是一个普通的函数，后面会探讨它</code></pre><p>打印出对象的类型</p><pre><code>println(set.javaClass)class java.util.HashSetprintln(map.javaClass)class java.util.HashMap</code></pre><p>从输出的内容可以看出，Kotlin并没有采用自己的集合类，而是使用标准的Java集合类，Kotlin可以更容易的和Java进行交互。但Kotlin不止如此,例如通过以下方式可以获取列表中最后一个元素或者可以获取到数字列表中最大值</p><pre><code>val strings = listOf(&quot;first&quot;,&quot;second&quot;,&quot;fourteenth&quot;)println(&quot;最后一个元素：${strings.last()}&quot;)val numbers = setOf(1,14,2)println(&quot;最大值：${numbers.max()}&quot;)</code></pre><p>打印</p><pre><code>最后一个元素：fourteenth最大值：14</code></pre><p>当然Kotlin还有更多其它的操作，在后续的章节中会详细讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h1&gt;&lt;p&gt;创建不可变的List集合,list引用不能通过 list[0] = “4” 这样的方式修改集合中的内容，尽管&lt;code&gt;li
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之异常</title>
    <link href="http://yoursite.com/2019/01/06/Kotlin/Kotlin%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/01/06/Kotlin/Kotlin之异常/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>和java中的异常一样，唯一不同的是kotlin的 throw结构是一个表达式,能作为另一个表达式中的一部分使用</p></blockquote><pre><code>val percentage = if(number in 0..100) number else throw IllegalArgumentException(&quot;A percentage must be between 0 and 100: $number&quot;)</code></pre><hr><h1 id="“try”-“catch”-和-“final”"><a href="#“try”-“catch”-和-“final”" class="headerlink" title="“try” “catch” 和 “final”"></a>“try” “catch” 和 “final”</h1><p>Kotlin不区分受检异常和未受检异常，不需要指定函数抛出异常</p><pre><code>fun readNumber(reader:BufferedReader): Int? {    try {        val line = reader.readLine();        return line.toInt()    }catch (e:NumberFormatException){        return null    }finally {        reader.close()    }}</code></pre><hr><h1 id="“try”作为表达式-表达式中最后一句作为返回值"><a href="#“try”作为表达式-表达式中最后一句作为返回值" class="headerlink" title="“try”作为表达式,表达式中最后一句作为返回值"></a>“try”作为表达式,表达式中最后一句作为返回值</h1><p>如果发生异常执行catch中的语句,那么catch中最后一句作为返回值，如果将return放到catch代码块中,如果发生异常，代码将不会继续往下执行，想继续往下执行，catch也需要一个值，例如将return改成 null，那么它就会是子居中最后一个表达式的值</p><pre><code>fun readNumber(reader: BufferedReader){    val number = try {            reader.readLine().toInt()        }catch(e:NumberFormatException){            return        }finally {            reader.close()        }    println(number)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;和java中的异常一样，唯一不同的是kotlin的 throw结构是一个表达式,能作为另一个表达式中的一部分使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;val percentage = if(number in 0..100) 
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之迭代事物</title>
    <link href="http://yoursite.com/2019/01/05/Kotlin/Kotlin%E4%B9%8B%E8%BF%AD%E4%BB%A3%E4%BA%8B%E7%89%A9/"/>
    <id>http://yoursite.com/2019/01/05/Kotlin/Kotlin之迭代事物/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-01-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p><strong>Kotlin</strong>有<code>while</code>循环和<code>do-while</code>循环，它们的语法和Java中的循环没什么区别:</p><pre><code>fun testWhile(){//先执行do一次，之后当while条件满足时继续执行do语句var flag : Booleando {    flag = true    println(&quot;first run&quot;)}while (!flag)}</code></pre><hr><h1 id="迭代数字-区间和数列"><a href="#迭代数字-区间和数列" class="headerlink" title="迭代数字:区间和数列"></a>迭代数字:区间和数列</h1><p>迭代左右都为闭区间</p><pre><code>fun testForLoop(){    val oneToBai = 1..100 //一个起始值,一个结束值,使用 .. 运算符表示区间    for (i in oneToBai){        println(&quot;计数: $i&quot;)    }}</code></pre><p>迭代带步长的数列</p><pre><code>fun testForLoop2(){    for (i in 100 downTo 1){ //数列递减,步长为1 (可使用 step     指定步长)        println(&quot;递减: $i&quot;)    }}</code></pre><p>迭代不包含指定结束值的半闭合区间,使用<code>until</code> 函数可以创建这样的区间,但是仅支持递增</p><pre><code>fun testForLoop3(){    val size = 10    for (i in 0 until size){        println(&quot;递增: $i&quot;)    }    //上面的for循环等同于    for (i in 0 .. size-1){        println(&quot;递增: $i&quot;)    }}</code></pre><hr><h1 id="迭代Map"><a href="#迭代Map" class="headerlink" title="迭代Map"></a>迭代Map</h1><p>使用map[key]读取值,并使用 map[key] = value 设置它们</p><pre><code>fun testMap(){    val binaryReps = TreeMap&lt;Char,String&gt;()    val a:Char = &apos;a&apos;    for (c in &apos;A&apos;..&apos;B&apos;){        val binary = Integer.toBinaryString(c.toInt()) //转成二进制        binaryReps[c] = binary        println(&quot;key: = $c&quot; + &quot; &quot; + &quot;value: ${binaryReps[c]}&quot;)    }    println(a)}</code></pre><p>使用 <code>in</code> 运算符来检查一个值是否在区间中,或者它的逆运算。<code>!in</code> 来检查这个值是否不在这个区间中</p><pre><code>fun isLetter(c:Char) = c in &apos;a&apos;..&apos;z&apos; || c in &apos;A&apos;..&apos;Z&apos;fun isNumber(c:Char) = c !in &apos;0&apos;..&apos;9&apos;</code></pre><p><code>in</code> 运算符也可用在when表达式中</p><pre><code>fun recognize(c:Char) =    when(c){        in &apos;a&apos;..&apos;z&apos; -&gt; &quot;It is a letter!&quot;        in &apos;0&apos;..&apos;9&apos; -&gt; &quot;It is a digit&quot;        else -&gt; &quot;I don&apos;t know...&quot;}</code></pre><p>区间不仅限于字符，只要一个类实现了 java.lang.Comparable接口,就可以创建这种类型的对象的区间。如果是这样的对象，并不能列举出这个区间中的所有对象，但是仍然可以使用 <code>in</code> 运算符来检查一个其他的对象是否属于这个区间</p><pre><code>fun inObject(){    println(&quot;Kotlin&quot; in &quot;Java&quot;..&quot;Scale&quot;) //这里的字符串是按自然顺序比较的}</code></pre><p><code>in</code> 同样适用于集合</p><pre><code>fun inSet(){    println(&quot;Kotlin&quot; in setOf(&quot;Java&quot;,&quot;Scale&quot;)) //这个集合不包含字符串Kotlin}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;while循环&quot;&gt;&lt;a href=&quot;#while循环&quot; class=&quot;headerlink&quot; title=&quot;while循环&quot;&gt;&lt;/a&gt;while循环&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Kotlin&lt;/strong&gt;有&lt;code&gt;while&lt;/code&gt;循环和&lt;code
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之枚举和when</title>
    <link href="http://yoursite.com/2019/01/04/Kotlin/Kotlin%E4%B9%8B%E6%9E%9A%E4%B8%BE%E5%92%8Cwhen/"/>
    <id>http://yoursite.com/2019/01/04/Kotlin/Kotlin之枚举和when/</id>
    <published>2019-01-03T16:00:00.000Z</published>
    <updated>2019-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="声明枚举类"><a href="#声明枚举类" class="headerlink" title="声明枚举类"></a>声明枚举类</h1><h2 id="声明简单的枚举"><a href="#声明简单的枚举" class="headerlink" title="声明简单的枚举"></a>声明简单的枚举</h2><pre><code>enum class Color{    RED,ORANGE,YELLOW,GREEN}</code></pre><h2 id="声明带属性的枚举，在每个常量创建的时候指定属性值"><a href="#声明带属性的枚举，在每个常量创建的时候指定属性值" class="headerlink" title="声明带属性的枚举，在每个常量创建的时候指定属性值"></a>声明带属性的枚举，在每个常量创建的时候指定属性值</h2><pre><code>enum class Color2(val r:Int,val g:Int,val b:Int){    RED(255,0,0),    GREEN(0,255,0),    BLUE(0,0,255),    ORANGE(255,255,0),    YELLOW(0,255,255),    WHITE(0,0,0);//这里必须要有分号,Kotlin中唯一必须使用分号的地方,如果在类中定义任何方法,则要使用分号把枚举常量列表和方法分开    fun rbg() = (r*256+g) * 256 + b}</code></pre><hr><h1 id="使用”when”处理枚举类"><a href="#使用”when”处理枚举类" class="headerlink" title="使用”when”处理枚举类"></a>使用”when”处理枚举类</h1><p><strong>when</strong>类似于Java中的<code>switch</code>关键字，不过它比<code>switch</code>功能更强大。它是一个有返回值的表达式，因此可以直接写一个直接返回when表达式的表达式函数体，</p><pre><code>fun getColor(color : Color2) = when(color) {    Color2.RED -&gt; &quot;red&quot;    Color2.GREEN -&gt; &quot;green&quot;    Color2.BLUE -&gt; &quot;blue&quot;    Color2.ORANGE -&gt; &quot;orange&quot;    Color2.YELLOW -&gt; &quot;yellow&quot;    Color2.WHITE -&gt; &quot;white&quot; }</code></pre><p>在一个<code>when</code>分支上合并多个选项</p><pre><code>fun getColor2(color:Color2) = when (color){    Color2.RED,Color2.GREEN -&gt; &quot;red or green&quot;    Color2.BLUE,Color2.YELLOW -&gt; &quot;blue or yellow&quot;    Color2.ORANGE -&gt; &quot;orange&quot;    Color2.WHITE -&gt; &quot;white&quot;}</code></pre><p><code>when</code>表达式的实参可以是任何对象,它被检查是否与分支条件相等</p><pre><code> when (setOf(c1,c2)) {//c1和c2分别是 RED、GREEN,反过来也行,它们的混合结果还是 ORANGE    // 列举能够混合的颜色    setOf(Color2.RED, Color2.GREEN) -&gt; Color2.ORANGE    setOf(Color2.GREEN, Color2.BLUE) -&gt; Color2.YELLOW    //如果没有任何其它分支，匹配这里就会执行    else -&gt; Color2.WHITE}</code></pre><p>使用不带参数的<code>when</code>，上面代码的效率可能有点低,每次调用fix这个函数时都会去创建一些<code>Set</code>实例，为了达到更好性能，可以换成以下这种方式,来避免创建垃圾对象</p><pre><code>fun mixOptimized(c1:Color2,c2:Color2) =    when{        c1 == Color2.RED &amp;&amp; c2 == Color2.GREEN || c1 == Color2.GREEN &amp;&amp; c2 == Color2.RED -&gt; Color2.ORANGE        c1 == Color2.GREEN &amp;&amp; c2 == Color2.BLUE || c1 == Color2.BLUE &amp;&amp; c2 == Color2.GREEN -&gt; Color2.YELLOW        else -&gt; Color2.WHITE    }</code></pre><hr><h1 id="智能转换-合并类型检查和转换"><a href="#智能转换-合并类型检查和转换" class="headerlink" title="智能转换:合并类型检查和转换"></a>智能转换:合并类型检查和转换</h1><p>假如要对<code>(1+2)+4</code>这样的算术表达式求值,如下：</p><pre><code>interface Expr  //定义一个接口class Num(val value:Int) : Expr   //使用冒号来标记Num类实现了Expr这个接口class Sum(val left:Expr,val right:Expr) : Expr //Sum运算的实参可以是任何Expr:Num或者另外一个Sum</code></pre><p>计算表达式的值</p><pre><code>fun sum() = eval(Sum(Sum(Num(1),Num(2)),Num(4)))fun eval(e:Expr):Int{if (e is Num){//使用 is 来判断一个变量是否是某种类型,类似于java中的instanceOf,如果检查过一个变量是某种类型,后面就不需要再转换它    val n = e as Num //使用as关键字来表示到特定类型的显示转换,在这里转换成Num其实是多余的    return n.value}if (e is Sum){    return eval(e.left) + eval(e.right)  //变量 e 被智能的转换了类型}throw IllegalArgumentException(&quot;Unknown expression&quot;)}</code></pre><p>简化上面的的<code>eval</code>函数，使用表达式函数体</p><pre><code>fun simplifyEval(e:Expr):Int =    if (e is Num) e.value //如果if分支下是一个代码块,则代码块中的最后一个表达式会被作为结果返回    else if (e is Sum) eval(e.left) + eval(e.right)    else throw IllegalArgumentException(&quot;Unknown expression&quot;)</code></pre><p>重构:用<code>when</code>代替<code>if</code>分支</p><pre><code>fun simplifyEval2(e:Expr):Int =    when(e){       is Num -&gt;            e.value       is Sum -&gt;            simplifyEval2(e.left) + simplifyEval2(e.right)        else -&gt;            throw IllegalArgumentException(&quot;Unknown expression&quot;)    }</code></pre><p>代码块作为<code>if</code>和<code>when</code>的分支</p><pre><code>fun evalWithLogging(e:Expr):Int =when(e){    is Num -&gt; {        println(&quot;num: ${e.value}&quot;)        e.value //代码块中最后的表达式会作为结果被返回    }    is Sum -&gt; {        val left = evalWithLogging(e.left)        val right = evalWithLogging(e.right)        println(&quot;sum: $left+$right&quot;)        left+right    }    else -&gt;        throw IllegalArgumentException(&quot;Unknown expression&quot;)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;声明枚举类&quot;&gt;&lt;a href=&quot;#声明枚举类&quot; class=&quot;headerlink&quot; title=&quot;声明枚举类&quot;&gt;&lt;/a&gt;声明枚举类&lt;/h1&gt;&lt;h2 id=&quot;声明简单的枚举&quot;&gt;&lt;a href=&quot;#声明简单的枚举&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之函数和变量</title>
    <link href="http://yoursite.com/2019/01/03/Kotlin/Kotlin%E4%B9%8B%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/01/03/Kotlin/Kotlin之函数和变量/</id>
    <published>2019-01-02T16:00:00.000Z</published>
    <updated>2019-01-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>自从Kotlin出来后，还没有好好地去学习它，而它带来的优势也是我所向往的。如今已经有很多大公司已经开始使用它进行项目开发了，作为一名Android开发工程师，接下来肯定是要学习一番，毕竟多掌握一门语言对本身而言也是一种优势。那么接下来，进入我的Kotlin学习之旅。</p></blockquote><p>从一个经典的例子开始,打印一个<code>Hello World</code>,代码如下:</p><pre><code>fun main(args:Array&lt;String&gt;){    println(&quot;Hello World&quot;)  }</code></pre><p>从上面的例子可以明显的看出<strong>Kotlin</strong>和<strong>Java</strong>在声明函数上的不同:</p><ul><li>kotlin使用关键词<strong>fun</strong>来声明一个函数</li><li>可以省略每行代码后的分号</li><li>参数的类型写在名称的后面</li><li>使用<code>println(...)</code>代替了Java中的<code>System.out.println(...)</code></li></ul><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>声明一个具有返回值的函数，求最大值</p><pre><code>fun max(a:Int,b:Int):Int {    return if(a &gt; b) a else b  //函数体}</code></pre><p>当方法内部为表达式时，可用表达式作为完整的函数体，并去掉花括号和<code>return</code>语句</p><pre><code>fun max(a:Int,b:Int):Int = if(a &gt; b) a else b //表达式函数体</code></pre><p>还可以进一步优化<code>max</code>函数,省掉返回类型(<strong>只有表达式函数体的返回值类型才可以省略</strong>)</p><pre><code>fun max(a:Int,b:Int) = if(a &gt; b) a else b</code></pre><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在<strong>Java</strong>中声明变量的时候以类型开始，而<strong>Kotlin</strong>刚好相反，以关键字开始，然后是变量名称，最后加上类型(不加也可以)</p><pre><code>val question = &quot;The Ultimate Question&quot;val a = 1 //省略了类型val b : Int = 2 //不省略类型//如果使用浮点类型,则变量默认是 Double 类型val number = 7.5e6 // &gt;&gt; 7.5 * 10^6</code></pre><hr><h1 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h1><p>使用<code>$</code>符号加变量名</p><pre><code>fun testStrTemplate(){    val a = 10    val  b = 15    val  name = if (a &gt; b) a else b    println(&quot;Hello,$name&quot;)}</code></pre><p>更复杂的表达式，需要用花括号括起来</p><pre><code>fun testStrTemplate2(){    val array = arrayOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)    println(&quot;测试: ${array[0]}&quot;)}</code></pre><p>在双引号中嵌套双引号</p><pre><code>fun testStrTemplate3(){    val array = arrayOf(1,2)    println(&quot;测试: ${if (array[0] &gt; 10) array[0] else &quot;someone&quot;}!&quot;)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;自从Kotlin出来后，还没有好好地去学习它，而它带来的优势也是我所向往的。如今已经有很多大公司已经开始使用它进行
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之类和属性</title>
    <link href="http://yoursite.com/2019/01/03/Kotlin/Kotlin%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/01/03/Kotlin/Kotlin之类和属性/</id>
    <published>2019-01-02T16:00:00.000Z</published>
    <updated>2019-01-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>在类中，声明属性和变量是一样的，使用<code>val</code>和<code>var</code>关键字，声明成<code>val</code>的属性是只读的，而<code>var</code>属性是可变的</p><pre><code>class Person{    val name:String = &quot;满天星&quot;//只读属性，生成一个字段和一个简单的getter    var age:Int = 20//可写属性，一个字段、一个getter和一个setter}</code></pre><p><strong>另外:</strong></p><ul><li>使用val声明属性，kotlin会把属性的getter方法暴露给java；</li><li>使用var声明属性,kotlin会把属性的getter和setter方法都暴露给java</li><li>Kotlin也可以使用java的Person类，并且如果Java类定义了两个名称为 getName和setName的方法，就把它们当做名称为name的属性访问</li></ul><p>调用构造方法不需要关键字<code>new</code>，可以直接访问属性,但其实调用的是<code>getter</code>方法</p><pre><code>fun testPerson() {    val person = Person(&quot;康栋普&quot;, 25)    person.age = 26    println(&quot;name: ${person.name}&quot; + &quot;\n&quot; + &quot;age: ${person.age}&quot;)    }</code></pre><hr><h1 id="自定义访问器"><a href="#自定义访问器" class="headerlink" title="自定义访问器"></a>自定义访问器</h1><p>假如声明一个矩形，它能判断自己是否为正方形，不需要单独的字段来存储这个值，而是随时可以通过检查矩形的长度是否相等来判断，<br>属性<code>isSquare</code>不需要字段来保存它的值,它只有一个自定义实现的<code>getter</code></p><pre><code>class Rectangle(val width: Int, val height: Int) {    val isSquare:Boolean    get() {        return width == height    }}</code></pre><p>更简洁的写法可以不使用带花括号的完整语法</p><pre><code>class Rectangle(val width: Int, val height: Int) {    val isSquare: Boolean get() = width == height}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h1&gt;&lt;p&gt;在类中，声明属性和变量是一样的，使用&lt;code&gt;val&lt;/code&gt;和&lt;code&gt;var&lt;/code&gt;关键字，声明成&lt;code&gt;val&lt;/c
      
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>在Properties配置文件中配置签名信息</title>
    <link href="http://yoursite.com/2018/09/25/Android/%E5%9C%A8Properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/09/25/Android/在Properties配置文件中配置签名信息/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2018-09-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新建Properties文件"><a href="#新建Properties文件" class="headerlink" title="新建Properties文件"></a>新建<code>Properties</code>文件</h1><p>在该文件中填写好签名的配置信息，等号左边为key，右边为value，在build需要根据key来获取value</p><pre><code>key_alias=namekey_password=123456store_file=../mykeystore.jksstore_password=123456</code></pre><h1 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h1><p>在app的<code>build.gradle</code>文件中定义一个方法，该方法中创建一个<code>Properties</code>对象，使用它来加载刚刚创建的签名配置文件(<code>sign.properties</code>)，代码如下：</p><pre><code> 读取签名配置并返回Propertiesdef buildSign() {     def Properties buildProperties = new Properties()     buildProperties.load(new FileInputStream(file(&quot;../local.properties&quot;)))     return buildProperties }</code></pre><h1 id="配置签名"><a href="#配置签名" class="headerlink" title="配置签名"></a>配置签名</h1><p>在app的<code>build.gradle</code>文件中<code>android</code>标签下配置你项目的<code>release</code>签名，然后调用<code>buildSign()</code>方法来获取<code>Properties</code>对象，通过此对象来获取对应的签名信息的<code>value</code>值，如下所示：</p><pre><code>android {   signingConfigs {           release {                 def Properties buildPro = buildSign()                 keyAlias buildPro[&apos;key_alias&apos;]                 keyPassword buildPro[&apos;key_password&apos;]                 storeFile file(buildPro[&apos;store_file&apos;])                 storePassword buildPro[&apos;store_password&apos;]                 }         } ...}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新建Properties文件&quot;&gt;&lt;a href=&quot;#新建Properties文件&quot; class=&quot;headerlink&quot; title=&quot;新建Properties文件&quot;&gt;&lt;/a&gt;新建&lt;code&gt;Properties&lt;/code&gt;文件&lt;/h1&gt;&lt;p&gt;在该文件中填写好签
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
</feed>
